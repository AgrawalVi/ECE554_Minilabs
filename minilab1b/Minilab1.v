//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Minilab1(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,
	
	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW
);

//=======================================================
//  REG/WIRE declarations
//=======================================================

// Avalon interconnect signals (loader master <-> mem_wrapper slave)
wire [31:0] address;
wire        read;
wire [63:0] readdata;
wire        readdatavalid;
wire        waitrequest;

// Loader -> compute FIFO fill
wire [7:0]  a_wren_in;
wire [63:0] a_data_in; // Flattened
wire        b_wren_in;
wire [7:0]  b_data_in;

// FIFO full status from compute
wire [7:0] a_full;
wire       b_full;

// Debug / results
wire        load_done;
wire [3:0]  l_state;
wire [3:0]  l_row;
wire [3:0]  l_byte;

wire        done;
wire [191:0] C_matrix_out; // Flattened
wire [2:0]  c_state;

wire clk;
assign clk = CLOCK_50;

//=======================================================
//  Module instantiation
//=======================================================

    // Instantiate provided Avalon-MM slave memory
    mem_wrapper mem (
        .clk(clk),
        .reset_n(KEY[0]),
        .address(address),
        .read(read),
        .readdata(readdata),
        .readdatavalid(readdatavalid),
        .waitrequest(waitrequest)
    );

    // Loader (Avalon-MM master)
    avalon_fifo_loader loader (
        .clk(clk),
        .rst_n(KEY[0]),

        .avm_address(address),
        .avm_read(read),
        .avm_readdata(readdata),
        .avm_readdatavalid(readdatavalid),
        .avm_waitrequest(waitrequest),

        .a_wren(a_wren_in),
        .a_data_out(a_data_in),
        .b_wren(b_wren_in),
        .b_data(b_data_in),

        .a_full(a_full),
        .b_full(b_full),

        .done(load_done),
        .dbg_state(l_state),
        .dbg_row(l_row),
        .dbg_byte(l_byte)
    );

    // Compute engine
    matrix_vector_multi dut (
        .CLOCK_50(clk),
        .KEY(KEY),

        .a_wren_in(a_wren_in),
        .a_data_in(a_data_in),
        .b_wren_in(b_wren_in),
        .b_data_in(b_data_in),

        .done(done),
        .C_matrix_out(C_matrix_out),
        .dbg_state(c_state),
        .a_full_out(a_full),
        .b_full_out(b_full)
    );

//=======================================================
//  Display logic
//=======================================================

// LEDR display: track states
// LEDR[3:0] - Loader State
// LEDR[6:4] - Compute State
// LEDR[7]   - Loader Done
// LEDR[8]   - Compute Done
assign LEDR = {1'b0, done, load_done, c_state, l_state};

// 7-segment display logic
// SW[2:0] selects which row of C_matrix to display (0-7)
reg [23:0] selected_c;

always @(*) begin
    case (SW[2:0])
        3'd0: selected_c = C_matrix_out[23:0];
        3'd1: selected_c = C_matrix_out[47:24];
        3'd2: selected_c = C_matrix_out[71:48];
        3'd3: selected_c = C_matrix_out[95:72];
        3'd4: selected_c = C_matrix_out[119:96];
        3'd5: selected_c = C_matrix_out[143:120];
        3'd6: selected_c = C_matrix_out[167:144];
        3'd7: selected_c = C_matrix_out[191:168];
        default: selected_c = 24'd0;
    endcase
end

function [6:0] seven_seg_decode;
    input [3:0] val;
    begin
        case (val)
            4'h0: seven_seg_decode = 7'b1000000;
            4'h1: seven_seg_decode = 7'b1111001;
            4'h2: seven_seg_decode = 7'b0100100;
            4'h3: seven_seg_decode = 7'b0110000;
            4'h4: seven_seg_decode = 7'b0011001;
            4'h5: seven_seg_decode = 7'b0010010;
            4'h6: seven_seg_decode = 7'b0000010;
            4'h7: seven_seg_decode = 7'b1111000;
            4'h8: seven_seg_decode = 7'b0000000;
            4'h9: seven_seg_decode = 7'b0011000;
            4'hA: seven_seg_decode = 7'b0001000;
            4'hB: seven_seg_decode = 7'b0000011;
            4'hC: seven_seg_decode = 7'b1000110;
            4'hD: seven_seg_decode = 7'b0100001;
            4'hE: seven_seg_decode = 7'b0000110;
            4'hF: seven_seg_decode = 7'b0001110;
            default: seven_seg_decode = 7'b1111111;
        endcase
    end
endfunction

always @(*) begin
    HEX0 = seven_seg_decode(selected_c[3:0]);
    HEX1 = seven_seg_decode(selected_c[7:4]);
    HEX2 = seven_seg_decode(selected_c[11:8]);
    HEX3 = seven_seg_decode(selected_c[15:12]);
    HEX4 = seven_seg_decode(selected_c[19:16]);
    HEX5 = seven_seg_decode(selected_c[23:20]);
end

endmodule
